You already got live OCM data and the UI is close. Now finish the MVP with the following behavioral requirements, UX rules, and acceptance tests. Please implement however you think best (clustering, virtualized layers, etc.) while keeping performance solid on low-end devices.

0) Context & invariants

Stack: Next.js 14, Leaflet. Env vars already set: OCM_API_KEY, STATIONS, CONNECTORS_HOSTNAME, etc.

“Heatmap”, “Markers”, “Council” toggles must remain.

Keep server-side API calls; no client exposure of private keys.

Keep the red top banner when we’re on demo/mock data only.

1) Initial map load must show real coverage, not a single blob

Problem: On first load we see one giant red heat spot and no markers until we zoom.
Goal: On initial load (London center), show an informative view:

A clustered marker layer (dozens of cluster bubbles across the whole viewport) that expands on zoom.

A heatmap that’s distributed across the city, not concentrated in one dot.

Implementation freedom:
Use supercluster (or Leaflet.markercluster equivalent) for markers and sync the heatmap to the exact same point set as the cluster’s underlying features for the current zoom. Heatmap radius and intensity should scale with zoom (smaller radius at high zoom, larger at low zoom). Throttle redraw to 60–120ms on zoom/pan.

Acceptance tests:

Open the app (default London). Without touching the map:

I see multiple cluster bubbles spread around Greater London, each with a count.

Heatmap shows multiple hotspots across the viewport (not one red circle).

Zoom out one level: cluster bubbles merge; heatmap smooths, still multi-modal.

Zoom in two levels: clusters split into individual markers + local heat spots.

2) Progressive, viewport-based data loading + caching

Fetch station points by viewport/bounds + zoom (server API).

On pan/zoom, debounce 300ms, request new tiles/bounds, and merge results into a local cache so going back doesn’t refetch.

Cap maximum points per request (e.g., 2–5k) and paginate automatically until either the cap or all points in bounds are loaded. Never block UI.

If the bounds have no stations, heatmap should gracefully fade out.

Acceptance tests:

Pan to High Wycombe, Oxford, Reading: markers and heatmap load within ~1s (depending on network).

Pan back to London: results appear immediately from cache (no spinner).

3) Marker & council visual identity (avoid color confusion)

Markers (stations): keep the current blue “pin” style; clusters use consistent blue outline with white count text.

Council overlay: keep the dashed orange boundary lines but DO NOT reuse the station color. Add a legend entry “Council boundaries” with a small orange dashed line swatch.

Council items must have popups too (see §5).

Acceptance tests:

Toggling “Council” on/off never changes station colors.

Council overlay always draws below markers but above base tiles.

4) Heatmap quality & numbers

Use the same point set used by the cluster layer for consistency.

Zoom-aware styling:

Radius scales with zoom (e.g., 35 → 12 px from z=10 → z=16)

Intensity normalized by points per cell, not absolute max count (avoid a single saturated red).

Gradient: green → yellow → orange → red (no solid black center).

Add small numeric annotations only when zoomed in enough (e.g., z ≥ 14), showing count within the local cell (avoid screen clutter).

Acceptance tests:

At city view: smooth multi-hotspot heatmap with no pure red disc at the center.

At street view: small, distinct hotspots; optional numbers are legible and don’t overlap badly.

5) Popups
5.1 Station popup (already close)

Keep title, address, connector count, Directions button.

Feedback form inline:

Buttons: Good / Bad (mutually exclusive state).

Free-text comment (≤ 280 chars).

“Submit Feedback” → POST /api/feedback with { stationId, rating: 'good'|'bad', comment, lat, lon, timestamp }.

Disable submit until Good/Bad selected.

Show a small toast “Thanks for your feedback!” on success.

5.2 Council popup (new)

On clicking a council boundary (or its centroids):

Show council name, population (if available), borough code, and a “Report boundary issue” mini-form (same POST endpoint, type=council, { councilId/slug }).

Different icon (e.g., small orange shield) so the popup affordance is obvious.

Acceptance tests:

Submitting station feedback stores it (you can log server-side for now).

Council popup appears and its feedback also posts successfully.

6) Controls & UX polish

Zoom to data button should fly to the tightest bounds that contain all station points currently loaded (include a small padding).

“Refresh” should refetch for the current bounds/zoom and clear only stale cache entries for those tiles.

Add “Loading…” skeleton in the bottom-left when a fetch is in flight (small unobtrusive pill).

Search:

First try geocoding via Postcodes.io; fallback to Nominatim.

On success, pan & fetch. On fail, show a discreet message under the search bar.

Acceptance tests:

“Zoom to data” frames all visible-layer stations correctly.

Panning while data is loading never freezes the UI.

7) Performance & stability

No layout shift on load: keep the map container at 100% height of viewport (minus header) and render placeholders while layers mount.

Run a quick audit: no unbounded console spam, no memory leaks on panning.

Ensure build passes and preview is production-quality.

Acceptance tests:

“npm run build” is clean.

No red errors in console during normal use.

8) Telemetry (optional but helpful)

When “Heatmap / Markers / Council” toggles change, send a lightweight analytics event (provider-agnostic; log to server for now): { feature: 'heatmap', enabled: true, ts }.

9) Done-Definition (attach screenshots)

City-wide screenshot on first load showing multiple clusters + distributed heatmap.

Zoomed-in screenshot showing individual stations, heatmap cells, and a station popup with feedback.

Screenshot with council popup open (distinct icon/color).

Very short clip/gif (optional): pan across city → new areas load with markers + heatmap.

Notes / Env

Keep API keys server-side only. If you need a small server endpoint to tile/aggregate OCM data, add it under /api/stations.

If you need to cap total points at city-view, prefer clustering + density tiles over dropping points silently.

Please implement, test against the acceptance checks above, and share the new live preview link + screenshots when complete.